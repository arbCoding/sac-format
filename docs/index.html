<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en xml:lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>sac-format</title>
<meta name=author content="Alexander R. Blanchette"><meta name=generator content="Org Mode"><link rel=stylesheet href=https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css><link rel=stylesheet href=https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js></script><script src=https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js></script><script src=https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js></script><div id=content class=content><h1 class=title>sac-format</h1><div id=table-of-contents role=doc-toc><h2>Table of Contents</h2><div id=text-table-of-contents role=doc-toc><ul><li><a href=#org663da6e>Introduction</a><ul><li><a href=#org8c6dc82>Why sac-format</a><ul><li><a href=#org632fb56>Trace class</a><li><a href=#org83ad615>Low-level I/O</a><li><a href=#orgf924eed>Safe</a><li><a href=#org9467084>Fast</a></ul></ul><li><a href=#org8fae194>Quickstart</a><ul><li><a href=#org77e1884>Cmake Integration</a><li><a href=#org98c136f>Build Instructions</a></ul><li><a href=#org2fff9bf>Notes</a><ul><li><a href=#org89136ae>Why C++20 and not C++23?</a><li><a href=#orge6fe43b>Dependencies</a><li><a href=#org0f36643>Endianness</a></ul></ul></div></div><hr><div id=outline-container-org663da6e class=outline-2><h2 id=org663da6e>Introduction</h2><div class=outline-text-2 id=text-org663da6e><p>sac-format is a single-header C++ library designed to make working with binary
<a href=https://ds.iris.edu/files/sac-manual/manual/file_format.html>SAC</a>-files as easy as possible. I wrote sac-format in the 2020 standard of the
C++ programming language (C++20), which has the benefit of being easy to read.
It follows the SAC-file format specifications&#8212;it is incomplete where the
specification is incomplete (XYZ files and a few header conventions, see below
for details).</div><div id=outline-container-org8c6dc82 class=outline-3><h3 id=org8c6dc82>Why sac-format</h3><div class=outline-text-3 id=text-org8c6dc82><p>sac-format is Free and Open Source Software (FOSS) released under the MIT
license. Anyone can use it, for any purpose (including proprietary software),
anywhere in the world. It is operating system agnostic and confirmed to run on
Windows, macOS, and Linux systems.</div><div id=outline-container-org632fb56 class=outline-4><h4 id=org632fb56>Trace class</h4><div class=outline-text-4 id=text-org632fb56><p>sac-format includes the <code>Trace</code> class for seismic traces that provides high-level
object-oriented abstraction to seismic data. With the <code>Trace</code> class, you don&rsquo;t
need to worry about manually reading SAC-files word-by-word. It is compatible
with <code>v6</code> and <code>v7</code> SAC-files and can automatically detect which on read. File output
defaults to <code>v7</code> SAC-files and there is a legacy-write function for <code>v6</code> output.</div></div><div id=outline-container-org83ad615 class=outline-4><h4 id=org83ad615>Low-level I/O</h4><div class=outline-text-4 id=text-org83ad615><p>If you want to roll your own SAC-file processing workflow you can use the
low-level I/O functionality built into sac-format. All functions are tested and
confirmed working&#8212;they&rsquo;re used to build the <code>Trace</code> class.</div></div><div id=outline-container-orgf924eed class=outline-4><h4 id=orgf924eed>Safe</h4><div class=outline-text-4 id=text-orgf924eed><p>sac-format is <b>safe</b>&#8212;testing is an important part of software development. The
sac-format library is extensively tested using the <a href=https://github.com/catchorg/Catch2>Catch2</a> testing framework.
Everything from low-level binary conversions to high-level <code>Trace</code> reading/writing
are tested and confirmed working. New tests added when they are imagined.</div></div><div id=outline-container-org9467084 class=outline-4><h4 id=org9467084>Fast</h4><div class=outline-text-4 id=text-org9467084><p>sac-format is <b>fast</b>&#8212;along with extensive testing, it is also extensively
benchmarked. Run the benchmarks yourself to determine how sac-format performs on
your system.</div></div></div></div><div id=outline-container-org8fae194 class=outline-2><h2 id=org8fae194>Quickstart</h2><div class=outline-text-2 id=text-org8fae194></div><div id=outline-container-org77e1884 class=outline-3><h3 id=org77e1884>Cmake Integration</h3></div><div id=outline-container-org98c136f class=outline-3><h3 id=org98c136f>Build Instructions</h3></div></div><div id=outline-container-org2fff9bf class=outline-2><h2 id=org2fff9bf>Notes</h2><div class=outline-text-2 id=text-org2fff9bf></div><div id=outline-container-org89136ae class=outline-3><h3 id=org89136ae>Why C++20 and not C++23?</h3><div class=outline-text-3 id=text-org89136ae><p>Compiler restrictions&#8212;many of the features of C++23 <a href=https://en.cppreference.com/w/cpp/compiler_support/23>require</a> GCC-13+ and
Clang-16+. Many systems, especially older ones, still use GCC-12 and
Clang-15&#8212;which has excellent support for <a href=https://en.cppreference.com/w/cpp/compiler_support/20>C++20</a>.<p>My goals are for sac-format to be accessible and modern&#8212;C++20 provides the bet
fit.</div></div><div id=outline-container-orge6fe43b class=outline-3><h3 id=orge6fe43b>Dependencies</h3></div><div id=outline-container-org0f36643 class=outline-3><h3 id=org0f36643>Endianness</h3><div class=outline-text-3 id=text-org0f36643><p>MacOS is a little-endian system, meaning it expects binary values to start from
the Least-Significant Bit (LSB). Linux is a big-endian system and expects binary
values to start from the Most-Significan Bit (MSB). This means that MacOS
reads/writes chunks of binary data from right-to-left, while on Linux it is done
from left-to-right. For most I/O this was a non-issue. However, for strings it
resulted in some amusing results.<p>For example: on MacOS, KEVNM header would be read in as &ldquo;Central Californ&rdquo; (16
character limit for that header) and Linux would read it as &ldquo;fornCaliral Cent&rdquo;.
The difference is easy to understand if we make the following map:<p>1 = &ldquo;Cent&rdquo;, 2 = &ldquo;ral&rdquo;, 3 = &ldquo;Cali&rdquo;, 4 = &ldquo;forn&rdquo;<p>The Mac output is &ldquo;1234&rdquo;, while Linux output is &ldquo;4321&rdquo;. I have fixed this by
checking system endianness in the string reading functions. If you get any funky
results, you should confirm the endianness of the input file.<p>This was not an issue with any other portions of the data in the binary file,
only the strings.</div></div></div></div><div id=postamble class=status><p class=author>Author: Alexander R. Blanchette<p class=email>Email: <a href=mailto:arbCoding@gmail.com>arbCoding@gmail.com</a><p class=validation><a href="https://validator.w3.org/check?uri=referer">Validate</a></div>