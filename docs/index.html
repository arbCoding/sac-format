<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en xml:lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>sac-format</title>
<meta name=author content="Alexander R. Blanchette"><meta name=generator content="Org Mode"><link rel=stylesheet href=https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css><link rel=stylesheet href=https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js></script><script src=https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js></script><script src=https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js></script><div id=content class=content><h1 class=title>sac-format</h1><div id=table-of-contents role=doc-toc><h2>Table of Contents</h2><div id=text-table-of-contents role=doc-toc><ul><li><a href=#orgac09871>Introduction</a><ul><li><a href=#org09d42a6>Why sac-format</a><ul><li><a href=#org5a8af7e>High-level Trace class</a><li><a href=#org6872539>Low-level I/O</a><li><a href=#orga58dd8b>Safe</a><li><a href=#org34bb7f6>Fast</a><li><a href=#org9c33976>Easy</a><li><a href=#orga47f6dd>Compact</a></ul></ul><li><a href=#orgb2239b8>Quickstart</a><ul><li><a href=#org7cbfbfc>Cmake Integration</a><li><a href=#orge8cb3da>Build Instructions</a><li><a href=#org71f271a>Examples</a><ul><li><a href=#orgc41d502>Empty Trace class</a></ul></ul><li><a href=#org838748c>Notes</a><ul><li><a href=#org6d258dc>Why C++20 and not C++23</a><li><a href=#org84a89b8>Dependencies</a><li><a href=#orgd4fad80>Endianness</a></ul></ul></div></div><hr><div id=outline-container-orgac09871 class=outline-2><h2 id=orgac09871>Introduction</h2><div class=outline-text-2 id=text-orgac09871><p>sac-format is a single-header statically-linked library designed to make working
with binary <a href=https://ds.iris.edu/files/sac-manual/manual/file_format.html>SAC</a>-files as easy as possible. I wrote sac-format in the 2020
standard of the C++ programming language (C++20), which has the benefit of being
easy to read. It follows the SAC-file format specifications&#8212;it is incomplete
where the specification is incomplete (XYZ files and a few header conventions,
see below for details).</div><div id=outline-container-org09d42a6 class=outline-3><h3 id=org09d42a6>Why sac-format</h3><div class=outline-text-3 id=text-org09d42a6><p>sac-format is Free and Open Source Software (FOSS) released under the MIT
license. Anyone can use it, for any purpose (including proprietary software),
anywhere in the world. It is operating system agnostic and confirmed to run on
Windows, macOS, and Linux systems.</div><div id=outline-container-org5a8af7e class=outline-4><h4 id=org5a8af7e>High-level Trace class</h4><div class=outline-text-4 id=text-org5a8af7e><p>sac-format includes the <code>Trace</code> class for seismic traces that provides high-level
object-oriented abstraction to seismic data. With the <code>Trace</code> class, you don&rsquo;t
need to worry about manually reading SAC-files word-by-word. It is compatible
with <code>v6</code> and <code>v7</code> SAC-files and can automatically detect the version upon reading.
File output defaults to <code>v7</code> SAC-files and there is a legacy-write function for <code>v6</code>
output.</div></div><div id=outline-container-org6872539 class=outline-4><h4 id=org6872539>Low-level I/O</h4><div class=outline-text-4 id=text-org6872539><p>If you want to roll your own SAC-file processing workflow you can use the
low-level I/O functionality built into sac-format. All functions are tested and
confirmed working&#8212;they&rsquo;re used to build the <code>Trace</code> class!</div></div><div id=outline-container-orga58dd8b class=outline-4><h4 id=orga58dd8b>Safe</h4><div class=outline-text-4 id=text-orga58dd8b><p>sac-format is <b>safe</b>&#8212;testing is an important part of software development. The
sac-format library is extensively tested using the <a href=https://github.com/catchorg/Catch2>Catch2</a> testing framework.
Everything from low-level binary conversions to high-level <code>Trace</code> reading/writing
are tested and confirmed working. New tests added when they are imagined.</div></div><div id=outline-container-org34bb7f6 class=outline-4><h4 id=org34bb7f6>Fast</h4><div class=outline-text-4 id=text-org34bb7f6><p>sac-format is <b>fast</b>&#8212;along with extensive testing, it is also extensively
benchmarked. Run the benchmarks yourself to determine how sac-format performs on
your system.</div></div><div id=outline-container-org9c33976 class=outline-4><h4 id=org9c33976>Easy</h4><div class=outline-text-4 id=text-org9c33976><p>sac-format is <b>easy</b>&#8212;it is single-header and object-oriented. It is easy to
integrate into any project using <a href=https://cmake.org/>CMake</a>. See the <a href=#orgb2239b8>Quickstart</a> section to get up and
running immediately.</div></div><div id=outline-container-orga47f6dd class=outline-4><h4 id=orga47f6dd>Compact</h4><div class=outline-text-4 id=text-orga47f6dd><p>In total (header + implementation&#8211;excluding comments) sac-format is under 1000
lines of code. This small size makes it easy to use on any sort of hardware
(such as a <a href=https://www.raspberrypi.com/>Raspberry Pi</a>).</div></div></div></div><div id=outline-container-orgb2239b8 class=outline-2><h2 id=orgb2239b8>Quickstart</h2><div class=outline-text-2 id=text-orgb2239b8></div><div id=outline-container-org7cbfbfc class=outline-3><h3 id=org7cbfbfc>Cmake Integration</h3></div><div id=outline-container-orge8cb3da class=outline-3><h3 id=orge8cb3da>Build Instructions</h3></div><div id=outline-container-org71f271a class=outline-3><h3 id=org71f271a>Examples</h3><div class=outline-text-3 id=text-org71f271a></div><div id=outline-container-orgc41d502 class=outline-4><h4 id=orgc41d502>Empty Trace class</h4><div class=outline-text-4 id=text-orgc41d502><div class=org-src-container><pre class="src src-cpp" id=orgc969aa7>#include &lt;iostream&gt;
#include &lt;sac_format.hpp&gt;

using namespace sacfmt;

int main() {
    Trace trace{};
    std::cout &lt;&lt; trace.kstnm &lt;&lt; '\n';
    return EXIT_SUCCESS;
}
</pre></div></div></div></div></div><div id=outline-container-org838748c class=outline-2><h2 id=org838748c>Notes</h2><div class=outline-text-2 id=text-org838748c></div><div id=outline-container-org6d258dc class=outline-3><h3 id=org6d258dc>Why C++20 and not C++23</h3><div class=outline-text-3 id=text-org6d258dc><p>Compiler restrictions&#8212;many of the features of C++23 <a href=https://en.cppreference.com/w/cpp/compiler_support/23>require</a> GCC-13+ and
Clang-16+. Many systems, especially older ones, still use GCC-12 and
Clang-15&#8212;which has excellent support for <a href=https://en.cppreference.com/w/cpp/compiler_support/20>C++20</a>.<p>My goals are for sac-format to be accessible and modern&#8212;C++20 provides the bet
fit.</div></div><div id=outline-container-org84a89b8 class=outline-3><h3 id=org84a89b8>Dependencies</h3></div><div id=outline-container-orgd4fad80 class=outline-3><h3 id=orgd4fad80>Endianness</h3><div class=outline-text-3 id=text-orgd4fad80><p>MacOS is a little-endian system, meaning it expects binary values to start from
the Least-Significant Bit (LSB). Linux is a big-endian system and expects binary
values to start from the Most-Significan Bit (MSB). This means that MacOS
reads/writes chunks of binary data from right-to-left, while on Linux it is done
from left-to-right. For most I/O this was a non-issue. However, for strings it
resulted in some amusing results.<p>For example: on MacOS, KEVNM header would be read in as &ldquo;Central Californ&rdquo; (16
character limit for that header) and Linux would read it as &ldquo;fornCaliral Cent&rdquo;.
The difference is easy to understand if we make the following map:<p>1 = &ldquo;Cent&rdquo;, 2 = &ldquo;ral&rdquo;, 3 = &ldquo;Cali&rdquo;, 4 = &ldquo;forn&rdquo;<p>The Mac output is &ldquo;1234&rdquo;, while Linux output is &ldquo;4321&rdquo;. I have fixed this by
checking system endianness in the string reading functions. If you get any funky
results, you should confirm the endianness of the input file.<p>This was not an issue with any other portions of the data in the binary file,
only the strings.</div></div></div></div><div id=postamble class=status><p class=author>Author: Alexander R. Blanchette<p class=email>Email: <a href=mailto:arbCoding@gmail.com>arbCoding@gmail.com</a><p class=validation><a href="https://validator.w3.org/check?uri=referer">Validate</a></div>