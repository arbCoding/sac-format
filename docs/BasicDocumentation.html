<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en-US><meta http-equiv=Content-Type content="text/xhtml;charset=utf-8"><meta http-equiv=X-UA-Compatible content="IE=11"><meta name=generator content="Doxygen 1.9.8"><meta name=viewport content="width=device-width,initial-scale=1"><title>sac-format: Basic Documentation</title>
<link href=tabs.css rel=stylesheet><script src=jquery.js></script><script src=dynsections.js></script><link href=navtree.css rel=stylesheet><script src=resize.js></script><script src=navtreedata.js></script><script src=navtree.js></script><link href=search/search.css rel=stylesheet><script src=search/searchdata.js></script><script src=search/search.js></script><link href=doxygen.css rel=stylesheet><link href=doxygen-awesome.css rel=stylesheet><div id=top><div id=titlearea><table cellspacing=0 cellpadding=0><tbody><tr id=projectrow><td id=projectalign><div id=projectname>sac-format<span id=projectnumber>&#160;0.6.0</span></div><div id=projectbrief>C++20 SAC (Seismic Analysis Code) File Library</div></table></div><script>var searchBox=new SearchBox("searchBox","search/",".html")</script><script src=menudata.js></script><script src=menu.js></script><script>$(function(){initMenu("",!0,!1,"search.php","Search"),$(document).ready(function(){init_search()})})</script><div id=main-nav></div></div><div id=side-nav class="ui-resizable side-nav-resizable"><div id=nav-tree><div id=nav-tree-contents><div id=nav-sync class=sync></div></div></div><div id=splitbar style=-moz-user-select:none class=ui-resizable-handle></div></div><script>$(document).ready(function(){initNavTree("BasicDocumentation.html",""),initResizable()})</script><div id=doc-content><div id=MSearchSelectWindow onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)"></div><div id=MSearchResultsWindow><div id=MSearchResults><div class=SRPage><div id=SRIndex><div id=SRResults></div><div class=SRStatus id=Loading>Loading...</div><div class=SRStatus id=Searching>Searching...</div><div class=SRStatus id=NoMatches>No Matches</div></div></div></div></div><div><div class=header><div class=headertitle><div class=title>Basic Documentation</div></div></div><div class=contents><div class=textblock><p>This section provides a brief overview of functionality and usage.<h1><a class=anchor id=autotoc_md25></a>Trace class</h1><p>The <code>Trace</code> class provides easy access to SAC-files in C++. Each SAC-file is a <code>Trace</code>; therefore, each <code>Trace</code> object is a seismic trace (seismogram).<h2><a class=anchor id=autotoc_md26></a>Reading SAC</h2><p>SAC-files can be read in by using the parameterized constructor with a <a href=https://en.cppreference.com/w/cpp/filesystem/path><code>std::filesystem::path</code></a> (<a href=https://en.cppreference.com/w/cpp/header/filesystem><code>&lt;filesystem></code></a>) or a <a href=https://en.cppreference.com/w/cpp/string/basic_string><code>std::string</code></a> (<a href=https://en.cppreference.com/w/cpp/header/string><code>&lt;string></code></a>) variable that corresponds to the location of the SAC-file.<p>For example:<div class=fragment><div class=line><span class=preprocessor>#include &lt;sac_foramt.hpp></span></div><div class=line><span class=preprocessor>#include &lt;filesystem></span></div><div class=line></div><div class=line><span class=keywordtype>int</span> main() {</div><div class=line>std::filesystem::path my_file{<span class=stringliteral>"/home/user/data/ANMO.SAC"</span>};</div><div class=line><a class="code hl_class" href=classsacfmt_1_1Trace.html>sacfmt::Trace</a> anmo{my_file};</div><div class=line><span class=keywordflow>return</span> EXIT_SUCCESS;</div><div class=line>}</div><div class=ttc id=aclasssacfmt_1_1Trace_html><div class=ttname><a href=classsacfmt_1_1Trace.html>sacfmt::Trace</a></div><div class=ttdoc>The Trace class.</div><div class=ttdef><b>Definition</b> sac_format.hpp:1080</div></div></div><h2><a class=anchor id=autotoc_md27></a>Writing SAC</h2><p>Writing SAC files can be done using one of two write functions.<h3><a class=anchor id=autotoc_md28></a>v7 files</h3><p>Use <code>write</code> (for example <code>trace.write(filename)</code>).<h3><a class=anchor id=autotoc_md29></a>v6 files</h3><p>Use <code>legacy_write</code> (for example <code>trace.legacy_write(filename)</code>).<h2><a class=anchor id=autotoc_md30></a>Getters and Setters</h2><p>Every SAC variable is accessed via getters and setters of the same name.<h3><a class=anchor id=autotoc_md31></a>Example Getters</h3><ul><li><code>trace.npts()</code><li><code>trace.data1()</code><li><code>trace.kstnm()</code></ul><h3><a class=anchor id=autotoc_md32></a>Example Setters</h3><ul><li><code>trace.kevnm("Event 1")</code><li><code>trace.evla(32.89)</code><li><code>trace.mag(3.21)</code></ul><h3><a class=anchor id=autotoc_md33></a>Setter rules</h3><p>Most of the setters are only constrained by the parameter type (single-precision, double-precision, boolean, etc.). <b>Some</b> setters are constrained by additional rules.<h4><a class=anchor id=autotoc_md34></a>Required for sanity</h4><p>Rules here are required because the sac-format library assumes them (not strictly required by the SAC format standard). For instance, the geometric functions assume certain bounds on latitudes and longitudes.<p>sac-format automatically imposes these rules.<h5><code>stla(input)</code></h5><p>Limited to [-90, 90] degrees, input that is outside that range is reduced using circular symmetry.<h5><code>stlo(input)</code></h5><p>Limited to [-180, 180] degrees, input that is outside that range is reduced using circular symmetry.<h5><code>evla(input)</code></h5><p>Limited to [-90, 90] degrees, input that is outside that range is reduced using circular symmetry.<h5><code>evlo(input)</code></h5><p>Limited to [-180, 180] degrees, input that is outside that range is reduced using circular symmetry.<h4><a class=anchor id=autotoc_md35></a>Required for safety</h4><p>Rules here are required by the SAC format standard. sac-format automatically imposes these rules to prevent the creation of corrupt sac-files.<h5><code>npts(input)</code></h5><p>Because <code>npts</code> defines the size of the data vectors, changing this value will change the size of <code>data1</code> and <code>data2</code>&#8727;. Increasing npts resizes the vectors (<a href=https://en.cppreference.com/w/cpp/container/vector/resize>std::vector::resize</a>) by placing zeros at the <b>end</b> of the vectors. Reducing npts resizes the vectors down to the <b>first npts</b> values.<p>Therefore, care must be taken to maintain separate copies of <code>data1</code> and <code>data2</code>&#8727; if you plan to manipulate the original data <b>after</b> resizing.<p>&#8727; data2 has <code>npts</code> only if it is legal, otherwise it is of size 0.<h5><code>leven(input)</code></h5><p>Changing the value of <code>leven</code> potentially changes the legality of <code>data2</code>, it also potentially affects the value of <code>iftype</code>.<p>If iftype>1, then leven must be <code>true</code> (evenly sampled data). Therefore, if leven is made <code>false</code> in this scenario (unevenly sampled data) then iftype becomes unset&#8727;.<p>If changing leven makes data2 legal&#8727;&#8727;, then data2 is qresized to have <code>npts</code> zeros.<p>&#8727; The SAC format defines the unset values for all data-types. For integers (like iftype) it is the integer value <code>-12345</code>.<p>&#8727;&#8727; If data2 was already legal, then it is unaffected.<h5><code>iftype(input)</code></h5><p>Changing the value of <code>iftype</code> poentially changes the legality of <code>data2</code>, it also potentially affects the value of <code>leven</code>.<p>If leven is <code>false</code>, then iftype must be either 1 or unset. Therefore, changing iftype to have a value >1 requires that leven becomes <code>true</code> (evenly sampled data).<p>If changing iftype makes data2 legal&#8727;, then data2 is resized to have <code>npts</code> zeros.<p>&#8727; If data2 was already legal, then it is unaffected.<h5><code>data1(input)</code></h5><p>If the size of <code>data1</code> is changed, then <code>npts</code> must change to reflect the new size. If <code>data2</code> is legal, this adjusts its size to match as well.<h5><code>data2(input)</code></h5><p>If the size of <code>data2</code> is changed to be larger than 0 and it is illegal, it is made legal by setting <code>iftype(2)</code> (spectral-data).<p>When the size of data2 changes, <code>npts</code> is updated to the new size and <code>data1</code> is resized to match.<p>If <code>data2</code> is made illegal, its size is reduced to 0 while <code>npts</code> and <code>data1</code> are unaffected.<h2><a class=anchor id=autotoc_md36></a>Convenience Methods</h2><h3><a class=anchor id=autotoc_md37></a>calc_geometry</h3><p>Calculate <code>gcarc</code>, <code>dist</code>, <code>az</code>, and <code>baz</code> assuming spherical Earth.<div class=fragment><div class=line>trace.stla(45.3);</div><div class=line>trace.stlo(34.5);</div><div class=line>trace.evla(18.5);</div><div class=line>trace.evlo(-34);</div><div class=line>trace.calc_geometry();</div><div class=line>std::cout &lt;&lt; <span class=stringliteral>"GcArc: "</span> &lt;&lt; trace.gcarc() &lt;&lt; <span class=charliteral>'\n'</span>;</div><div class=line>std::cout &lt;&lt; <span class=stringliteral>"Dist: "</span> &lt;&lt; trace.dist() &lt;&lt; <span class=charliteral>'\n'</span>;</div><div class=line>std::cout &lt;&lt; <span class=stringliteral>"Azimuth: "</span> &lt;&lt; trace.az() &lt;&lt; <span class=charliteral>'\n'</span>;</div><div class=line>std::cout &lt;&lt; <span class=stringliteral>"BAzimuth: "</span> &lt;&lt; trace.baz() &lt;&lt; <span class=charliteral>'\n'</span>;</div></div><h3><a class=anchor id=autotoc_md38></a>frequency</h3><p>Calculate frequency from <code>delta</code>.<div class=fragment><div class=line><span class=keywordtype>double</span> frequency{trace.frequency()};</div></div><h3><a class=anchor id=autotoc_md39></a>date</h3><p>Return <code>std::string</code> formatted as <code>YYYY-JJJ</code> from <code>nzyear</code> and <code>nzjday</code>.<div class=fragment><div class=line>std::string date{trace.date()};</div></div><h3><a class=anchor id=autotoc_md40></a>time</h3><p>Return <code>std::string</code> formatted as <code>HH:MM:SS.xxx</code> from <code>nzhour</code>, <code>nzmin</code>, <code>nzsec</code>, and <code>nzmsec</code>.<div class=fragment><div class=line>std::string time{trace.time()};</div></div><h2><a class=anchor id=autotoc_md41></a>Exceptions</h2><p>sac-format throws exceptions of type <code><a class=el href=classsacfmt_1_1io__error.html title="Class for generic I/O exceptions.">sacfmt::io_error</a></code> (inherits <a href=https://en.cppreference.com/w/cpp/error/exception><code>std::exception</code></a>) in the event of a failure to read/write a SAC-file.<h1><a class=anchor id=autotoc_md42></a>Convenience Functions</h1><h2><a class=anchor id=autotoc_md43></a>degrees_to_radians</h2><p>Convert decimal degrees to radians.<div class=fragment><div class=line><span class=keywordtype>double</span> radians{<a class="code hl_function" href=namespacesacfmt.html#a00d680406a083cec842eb0700ea0dad4>sacfmt::degrees_to_radians</a>(degrees)};</div><div class=ttc id=anamespacesacfmt_html_a00d680406a083cec842eb0700ea0dad4><div class=ttname><a href=namespacesacfmt.html#a00d680406a083cec842eb0700ea0dad4>sacfmt::degrees_to_radians</a></div><div class=ttdeci>double degrees_to_radians(double degrees) noexcept</div><div class=ttdoc>Convert decimal degrees to radians.</div><div class=ttdef><b>Definition</b> sac_format.cpp:663</div></div></div><h2><a class=anchor id=autotoc_md44></a>radians_to_degrees</h2><p>Convert radians to decimal degrees.<div class=fragment><div class=line><span class=keywordtype>double</span> degrees{<a class="code hl_function" href=namespacesacfmt.html#a99b9d2001e973091998a61286d0fdf1b>sacfmt::radians_to_degrees</a>(radians)};</div><div class=ttc id=anamespacesacfmt_html_a99b9d2001e973091998a61286d0fdf1b><div class=ttname><a href=namespacesacfmt.html#a99b9d2001e973091998a61286d0fdf1b>sacfmt::radians_to_degrees</a></div><div class=ttdeci>double radians_to_degrees(double radians) noexcept</div><div class=ttdoc>Convert radians to decimal degrees.</div><div class=ttdef><b>Definition</b> sac_format.cpp:677</div></div></div><h2><a class=anchor id=autotoc_md45></a>gcarc</h2><p>Calculate great-circle arc distance (spherical planet).<div class=fragment><div class=line><span class=keyword>const</span> point location1{coord{latitude1}, coord{longitude1}};</div><div class=line><span class=keyword>const</span> point location2{coord{latitude2}, coord{longitude2}};</div><div class=line><span class=keywordtype>double</span> <a class="code hl_function" href=namespacesacfmt.html#aa98f4b65d8990c64857867b3dd4521ac>gcarc</a>{<a class="code hl_enumvalue" href=namespacesacfmt.html#aa519c4963e3863fdd55fad06655fad96a2d6e2cba500506ce3480820230f00624>sacfmt::gcarc</a>(location1, location2)};</div><div class=ttc id=anamespacesacfmt_html_aa519c4963e3863fdd55fad06655fad96a2d6e2cba500506ce3480820230f00624><div class=ttname><a href=namespacesacfmt.html#aa519c4963e3863fdd55fad06655fad96a2d6e2cba500506ce3480820230f00624>sacfmt::name::gcarc</a></div><div class=ttdeci>@ gcarc</div></div><div class=ttc id=anamespacesacfmt_html_aa98f4b65d8990c64857867b3dd4521ac><div class=ttname><a href=namespacesacfmt.html#aa98f4b65d8990c64857867b3dd4521ac>sacfmt::gcarc</a></div><div class=ttdeci>double gcarc(point location1, point location2) noexcept</div><div class=ttdoc>Calculate great circle arc distance in decimal degrees between two points.</div><div class=ttdef><b>Definition</b> sac_format.cpp:739</div></div></div><h2><a class=anchor id=autotoc_md46></a>azimuth</h2><p>Calculate azimuth between two points (spherical planet).<div class=fragment><div class=line><span class=keyword>const</span> point location1{coord{latitude1}, coord{longitude1}};</div><div class=line><span class=keyword>const</span> point location2{coord{latitude2}, coord{longitude2}};</div><div class=line><span class=keywordtype>double</span> <a class="code hl_function" href=namespacesacfmt.html#a8a212ae42c7b5ca5ad7def340347bb86>azimuth</a>{<a class="code hl_function" href=namespacesacfmt.html#a8a212ae42c7b5ca5ad7def340347bb86>sacfmt::azimuth</a>(location2, location1)};</div><div class=line><span class=keywordtype>double</span> back_azimuth{<a class="code hl_function" href=namespacesacfmt.html#a8a212ae42c7b5ca5ad7def340347bb86>sacfmt::azimuth</a>(location1, location2)};</div><div class=ttc id=anamespacesacfmt_html_a8a212ae42c7b5ca5ad7def340347bb86><div class=ttname><a href=namespacesacfmt.html#a8a212ae42c7b5ca5ad7def340347bb86>sacfmt::azimuth</a></div><div class=ttdeci>double azimuth(point location1, point location2) noexcept</div><div class=ttdoc>Calculate azimuth between two points.</div><div class=ttdef><b>Definition</b> sac_format.cpp:770</div></div></div><h2><a class=anchor id=autotoc_md47></a>limit_360</h2><p>Take arbitrary value of degrees and unwrap to [0, 360].<div class=fragment><div class=line><span class=keywordtype>double</span> degrees_limited{<a class="code hl_function" href=namespacesacfmt.html#a7ed2843f8d75e1179df0b235d5e39277>sacfmt::limit_360</a>(degrees)};</div><div class=ttc id=anamespacesacfmt_html_a7ed2843f8d75e1179df0b235d5e39277><div class=ttname><a href=namespacesacfmt.html#a7ed2843f8d75e1179df0b235d5e39277>sacfmt::limit_360</a></div><div class=ttdeci>double limit_360(double degrees) noexcept</div><div class=ttdoc>Takes a decimal degree value and constrains it to full circle using symmetry.</div><div class=ttdef><b>Definition</b> sac_format.cpp:798</div></div></div><h2><a class=anchor id=autotoc_md48></a>limit_180</h2><p>Take arbitrary value of degrees and unwrap to [-180, 180]. Useful for longitude.<div class=fragment><div class=line><span class=keywordtype>double</span> degrees_limited{<a class="code hl_function" href=namespacesacfmt.html#a5408a7de5eb672b341de42e6804d82e1>sacfmt::limit_180</a>(degrees)};</div><div class=ttc id=anamespacesacfmt_html_a5408a7de5eb672b341de42e6804d82e1><div class=ttname><a href=namespacesacfmt.html#a5408a7de5eb672b341de42e6804d82e1>sacfmt::limit_180</a></div><div class=ttdeci>double limit_180(double degrees) noexcept</div><div class=ttdoc>Takes a decimal degree value and constrains it to a half circle using symmetry.</div><div class=ttdef><b>Definition</b> sac_format.cpp:824</div></div></div><h2><a class=anchor id=autotoc_md49></a>limit_90</h2><p>Take arbitrary value of degrees and unwrap to [-90, 90]. Useful for latitude.<div class=fragment><div class=line><span class=keywordtype>double</span> degrees_limited{<a class="code hl_function" href=namespacesacfmt.html#aa158c96f64f3f63d1c2c1c670b1ad8e9>sacfmt::limit_90</a>(degrees)};</div><div class=ttc id=anamespacesacfmt_html_aa158c96f64f3f63d1c2c1c670b1ad8e9><div class=ttname><a href=namespacesacfmt.html#aa158c96f64f3f63d1c2c1c670b1ad8e9>sacfmt::limit_90</a></div><div class=ttdeci>double limit_90(double degrees) noexcept</div><div class=ttdoc>Takes a decimal degree value and constrains it to a quarter circle using symmetry.</div><div class=ttdef><b>Definition</b> sac_format.cpp:844</div></div></div><h1><a class=anchor id=autotoc_md50></a>Low-Level I/O</h1><p>Low-level I/O functions are discussed below.<h2><a class=anchor id=autotoc_md51></a>Binary conversion</h2><h3><a class=anchor id=autotoc_md52></a>int_to_binary and binary_to_int</h3><p>Conversion pair for binary representation of integer values.<div class=fragment><div class=line><span class=keyword>const</span> <span class=keywordtype>int</span> input{10};</div><div class=line><span class=comment>// sacfmt::word_one is alias for std::bitset&lt;32> (one word)</span></div><div class=line><a class="code hl_typedef" href=namespacesacfmt.html#af5c0c15ea4154bc14bf4083f1ebaed08>sacfmt::word_one</a> binary{<a class="code hl_function" href=namespacesacfmt.html#a4f9abce8af2b81b8c5b1d132c1c024cb>sacfmt::int_to_binary</a>(input)};</div><div class=line><span class=keyword>const</span> <span class=keywordtype>int</span> output{<a class="code hl_function" href=namespacesacfmt.html#a68fa833a9ba91eff6e58afabbb993030>sacfmt::binary_to_int</a>(binary)};</div><div class=line>std::cout &lt;&lt; (input == output) &lt;&lt; <span class=charliteral>'\n'</span>;</div><div class=ttc id=anamespacesacfmt_html_a4f9abce8af2b81b8c5b1d132c1c024cb><div class=ttname><a href=namespacesacfmt.html#a4f9abce8af2b81b8c5b1d132c1c024cb>sacfmt::int_to_binary</a></div><div class=ttdeci>word_one int_to_binary(int num) noexcept</div><div class=ttdoc>Convert integer to 32-bit (one word) binary bitset.</div><div class=ttdef><b>Definition</b> sac_format.cpp:67</div></div><div class=ttc id=anamespacesacfmt_html_a68fa833a9ba91eff6e58afabbb993030><div class=ttname><a href=namespacesacfmt.html#a68fa833a9ba91eff6e58afabbb993030>sacfmt::binary_to_int</a></div><div class=ttdeci>int binary_to_int(word_one bin) noexcept</div><div class=ttdoc>Convert 32-bit (one word) binary bitset to integer.</div><div class=ttdef><b>Definition</b> sac_format.cpp:88</div></div><div class=ttc id=anamespacesacfmt_html_af5c0c15ea4154bc14bf4083f1ebaed08><div class=ttname><a href=namespacesacfmt.html#af5c0c15ea4154bc14bf4083f1ebaed08>sacfmt::word_one</a></div><div class=ttdeci>std::bitset&lt; binary_word_size > word_one</div><div class=ttdoc>One binary word (useful for non-strings).</div><div class=ttdef><b>Definition</b> sac_format.hpp:84</div></div></div><h3><a class=anchor id=autotoc_md53></a>float_to_binary and binary_to_float</h3><p>Conversion pair for binary representation of floating-point values.<div class=fragment><div class=line><span class=keyword>const</span> <span class=keywordtype>float</span> input{5F};</div><div class=line><a class="code hl_typedef" href=namespacesacfmt.html#af5c0c15ea4154bc14bf4083f1ebaed08>sacfmt::word_one</a> binary{<a class="code hl_function" href=namespacesacfmt.html#af4a4780edbc39006203daca058c71e9e>sacfmt::float_to_binary</a>(input)};</div><div class=line><span class=keyword>const</span> <span class=keywordtype>float</span> output{<a class="code hl_function" href=namespacesacfmt.html#ac112734df4871952d3d85f9c8abd9632>sacfmt::binary_to_float</a>(binary)};</div><div class=line>std::cout &lt;&lt; (input == output) &lt;&lt; <span class=charliteral>'\n'</span>;</div><div class=ttc id=anamespacesacfmt_html_ac112734df4871952d3d85f9c8abd9632><div class=ttname><a href=namespacesacfmt.html#ac112734df4871952d3d85f9c8abd9632>sacfmt::binary_to_float</a></div><div class=ttdeci>float binary_to_float(const word_one &amp;bin) noexcept</div><div class=ttdoc>Convert 32-bit (one word) binary bitset to a floating-point value.</div><div class=ttdef><b>Definition</b> sac_format.cpp:127</div></div><div class=ttc id=anamespacesacfmt_html_af4a4780edbc39006203daca058c71e9e><div class=ttname><a href=namespacesacfmt.html#af4a4780edbc39006203daca058c71e9e>sacfmt::float_to_binary</a></div><div class=ttdeci>word_one float_to_binary(float num) noexcept</div><div class=ttdoc>Convert floating-point value to 32-bit (one word) binary bitset.</div><div class=ttdef><b>Definition</b> sac_format.cpp:111</div></div></div><h3><a class=anchor id=autotoc_md54></a>double_to_binary and binary_to_double</h3><p>Conversion pair for binary representation of double-precision values.<div class=fragment><div class=line><span class=keyword>const</span> <span class=keywordtype>double</span> input{1e5};</div><div class=line><span class=comment>// sacfmt::word_two is alias for std::bitset&lt;64> (two words)</span></div><div class=line><a class="code hl_typedef" href=namespacesacfmt.html#a98117fb2513e24dc91cfdd46a8e214a3>sacfmt::word_two</a> binary{<a class="code hl_function" href=namespacesacfmt.html#a8fdeb83989f46023ca1a04a7d398f0c9>sacfmt::double_to_binary</a>(input)};</div><div class=line><span class=keyword>const</span> <span class=keywordtype>double</span> output{<a class="code hl_function" href=namespacesacfmt.html#ae5dc64c24fb9451b530bb34c79dd9570>sacfmt::binary_to_double</a>(binary)};</div><div class=line>std::cout &lt;&lt; (input == output) &lt;&lt; <span class=charliteral>'\n'</span>;</div><div class=ttc id=anamespacesacfmt_html_a8fdeb83989f46023ca1a04a7d398f0c9><div class=ttname><a href=namespacesacfmt.html#a8fdeb83989f46023ca1a04a7d398f0c9>sacfmt::double_to_binary</a></div><div class=ttdeci>word_two double_to_binary(double num) noexcept</div><div class=ttdoc>Convert double-precision value to 64-bit (two words) binary bitset.</div><div class=ttdef><b>Definition</b> sac_format.cpp:143</div></div><div class=ttc id=anamespacesacfmt_html_a98117fb2513e24dc91cfdd46a8e214a3><div class=ttname><a href=namespacesacfmt.html#a98117fb2513e24dc91cfdd46a8e214a3>sacfmt::word_two</a></div><div class=ttdeci>std::bitset&lt; static_cast&lt; size_t >(2) *binary_word_size > word_two</div><div class=ttdoc>Two binary words (useful for strings).</div><div class=ttdef><b>Definition</b> sac_format.hpp:86</div></div><div class=ttc id=anamespacesacfmt_html_ae5dc64c24fb9451b530bb34c79dd9570><div class=ttname><a href=namespacesacfmt.html#ae5dc64c24fb9451b530bb34c79dd9570>sacfmt::binary_to_double</a></div><div class=ttdeci>double binary_to_double(const word_two &amp;bin) noexcept</div><div class=ttdoc>Convert 64-bit (two words) binary bitset to double-precision value.</div><div class=ttdef><b>Definition</b> sac_format.cpp:159</div></div></div><h3><a class=anchor id=autotoc_md55></a>string_to_binary and binary_to_string</h3><p>Conversion pair for binary representation of two-word (regular) string values.<div class=fragment><div class=line><span class=keyword>const</span> std::string input{<span class=stringliteral>"NmlStrng"</span>};</div><div class=line><a class="code hl_typedef" href=namespacesacfmt.html#a98117fb2513e24dc91cfdd46a8e214a3>sacfmt::word_two</a> binary{<a class="code hl_function" href=namespacesacfmt.html#a9e62be10cbc389a820a4715791b83a60>sacfmt::string_to_binary</a>(input)};</div><div class=line><span class=keyword>const</span> std::string output{<a class="code hl_function" href=namespacesacfmt.html#ac47953a20fbff537ca9314f9e737fea8>sacfmt::binary_to_string</a>(binary)};</div><div class=line>std::cout &lt;&lt; (input == output) &lt;&lt; <span class=charliteral>'\n'</span>;</div><div class=ttc id=anamespacesacfmt_html_a9e62be10cbc389a820a4715791b83a60><div class=ttname><a href=namespacesacfmt.html#a9e62be10cbc389a820a4715791b83a60>sacfmt::string_to_binary</a></div><div class=ttdeci>word_two string_to_binary(std::string str) noexcept</div><div class=ttdoc>Convert string to a 64-bit (two word) binary bitset.</div><div class=ttdef><b>Definition</b> sac_format.cpp:282</div></div><div class=ttc id=anamespacesacfmt_html_ac47953a20fbff537ca9314f9e737fea8><div class=ttname><a href=namespacesacfmt.html#ac47953a20fbff537ca9314f9e737fea8>sacfmt::binary_to_string</a></div><div class=ttdeci>std::string binary_to_string(const word_two &amp;str) noexcept</div><div class=ttdoc>Convert a 64-bit (two word) binary bitset to a string.</div><div class=ttdef><b>Definition</b> sac_format.cpp:298</div></div></div><h3><a class=anchor id=autotoc_md56></a>long_string_to_binary and binary_to_long_string</h3><p>Conversion pair for binary representation of four-word (only <code>kstnm</code> string values.<div class=fragment><div class=line><span class=keyword>const</span> std::string input{<span class=stringliteral>"The Long String"</span>};</div><div class=line><span class=comment>// sacfmt::word_four is alias for std::bitset&lt;128> (four words)</span></div><div class=line><a class="code hl_typedef" href=namespacesacfmt.html#afe2f8aa302f7a6c76da07919f206cf2c>sacfmt::word_four</a> binary{<a class="code hl_function" href=namespacesacfmt.html#aa561d911c782afe814321e13eacf3494>sacfmt::long_string_to_binary</a>(input)};</div><div class=line><span class=keyword>const</span> std::string output{<a class="code hl_function" href=namespacesacfmt.html#ab834d4178a181eae51090e2bbfc2ec77>sacfmt::binary_to_long_string</a>(binary)};</div><div class=line>std::cout &lt;&lt; (input == output) &lt;&lt; <span class=charliteral>'\n'</span>;</div><div class=ttc id=anamespacesacfmt_html_aa561d911c782afe814321e13eacf3494><div class=ttname><a href=namespacesacfmt.html#aa561d911c782afe814321e13eacf3494>sacfmt::long_string_to_binary</a></div><div class=ttdeci>word_four long_string_to_binary(std::string str) noexcept</div><div class=ttdoc>Convert a string to a 128-bit (four word) binary bitset.</div><div class=ttdef><b>Definition</b> sac_format.cpp:315</div></div><div class=ttc id=anamespacesacfmt_html_ab834d4178a181eae51090e2bbfc2ec77><div class=ttname><a href=namespacesacfmt.html#ab834d4178a181eae51090e2bbfc2ec77>sacfmt::binary_to_long_string</a></div><div class=ttdeci>std::string binary_to_long_string(const word_four &amp;str) noexcept</div><div class=ttdoc>Convert a 128-bit (four word) binary bitset to a string.</div><div class=ttdef><b>Definition</b> sac_format.cpp:332</div></div><div class=ttc id=anamespacesacfmt_html_afe2f8aa302f7a6c76da07919f206cf2c><div class=ttname><a href=namespacesacfmt.html#afe2f8aa302f7a6c76da07919f206cf2c>sacfmt::word_four</a></div><div class=ttdeci>std::bitset&lt; static_cast&lt; size_t >(4) *binary_word_size > word_four</div><div class=ttdoc>Four binary words (kEvNm only).</div><div class=ttdef><b>Definition</b> sac_format.hpp:88</div></div></div><h2><a class=anchor id=autotoc_md57></a>Reading/Writing</h2><p><b>NOTE</b> that care must be taken when using them to ensure that safe input is provided; the <code>Trace</code> class ensures safe I/O, low-level I/O functions do not necessarily ensure safety.<h3><a class=anchor id=autotoc_md58></a>read_word, read_two_words, read_four_words, and read_data</h3><p>Functions to read one-, two-, and four-word variables (depending on the header) and an arbitrary amount of binary data (exclusive to <code>data1</code> and <code>data2</code>).<h3><a class=anchor id=autotoc_md59></a>convert_to_word, convert_to_words, and bool_to_word</h3><p>Takes objects and converts them into <code>std::vector&lt;char></code> (<code>convert_to_word</code> and <code>bool_to_word</code>) or <code>std::array&lt;char, N></code> (<code>convert_to_words</code>, N = # of words).<h3><a class=anchor id=autotoc_md60></a>write_words</h3><p>Writes input words (as <code>std::vector&lt;char></code>) to a binary SAC-file.<h2><a class=anchor id=autotoc_md61></a>Utility</h2><h3><a class=anchor id=autotoc_md62></a>concat_words</h3><p>Concatenates words taking into account the system endianness.<h3><a class=anchor id=autotoc_md63></a>bits_string and string_bits</h3><p>Template function that performs conversion of binary strings of arbitrary length to an arbitrary number of words.<h3><a class=anchor id=autotoc_md64></a>remove_leading_spaces and remove_trailing_spaces</h3><p>Remove leading and trailing blank spaces from strings assuming ASCII convention (space character is integer 32, below that value are control characters that also appear as blank spaces).<h3><a class=anchor id=autotoc_md65></a>string_cleaning</h3><p>Ensures string does not contain an internal termination character (<code>\0</code>) and removes it if present, then removes blank spaces.<h3><a class=anchor id=autotoc_md66></a>prep_string</h3><p>Performs <code>string_cleaning</code> followed by string truncation/padding to the necessary length.<h3><a class=anchor id=autotoc_md67></a>equal_within_tolerance</h3><p>Floating-point/double-precision equality within a provided tolerance (default is <code>f_eps</code>, defined in <code>sac_format.hpp</code>).<h1><a class=anchor id=autotoc_md68></a>Testing</h1><p>Unit- and integration-tests (using Catch2) are contained in the <code>tests</code> folder. They include:<ul><li><code>binary_conversions.cpp</code> confirms that conversion to/from binary functions correctly.<li><code>constants.cpp</code> confirms constant values (e.g. SAC magic numbers) are correct.<li><code>datetime.cpp</code> confirms date and time functions work correctly.<li><code>geometry.cpp</code> confirms that geometric calculations are correct (azimuth, greater-circle arc-length, etc.).<li><code>trace.cpp</code> confirms that the trace class is functioning correctly (I/O, exceptions, bounded headers, etc.).</ul><p>The tests compile to the following programs:<ul><li><code>basic_tests</code> (binary conversions and constants).<li><code>datetime_tests</code><li><code>geometry_tests</code><li><code>trace_tests</code></ul><p>Test coverage details are visible on <a href=https://app.codecov.io/gh/arbCoding/sac-format>CodeCov.io</a> and <a href=https://app.codacy.com/gh/arbCoding/sac-format/dashboard>Codacy.com</a>. All tests can be locally-run to ensure full functionality and compliance.<h2><a class=anchor id=autotoc_md69></a>Errors only</h2><p>By default each test prints out a pass summary, without details unless an error is encountered.<h2><a class=anchor id=autotoc_md70></a>Full output</h2><p>By passing the <code>--success</code> flag you can see the full results of all tests.<h2><a class=anchor id=autotoc_md71></a>Compact output</h2><p>The full output is verbose, using the compact reporter will condense the test results (<code>--reporter=compact</code>).<h2><a class=anchor id=autotoc_md72></a>Additional options</h2><p>To see additional options, run <code>-?</code>.<h2><a class=anchor id=autotoc_md73></a>Using ctest</h2><p>If you have CMake install, you can run the tests using <code>ctest</code>.<h1><a class=anchor id=autotoc_md74></a>Benchmarking</h1><p><code>benchmark.cpp</code> contains the benchmarks. Running it locally will provide information on how long each function takes; benchmarks start with the low-level I/O function and build up to Trace reading, writing, and equality comparison.<p>To view available optional flags, run <code>becnhmark -?</code>.<h1><a class=anchor id=autotoc_md75></a>Source File List</h1><h2><a class=anchor id=autotoc_md76></a>Core</h2><p>The two core files are split in the standard interface (hpp)/implementation (cpp) format.<h3><a class=anchor id=autotoc_md77></a>sac_format.hpp</h3><p>Interface: function declarations and constants.<h3><a class=anchor id=autotoc_md78></a>sac_format.cpp</h3><p>Implementation: function details.<h2><a class=anchor id=autotoc_md79></a>Testing and Benchmarking</h2><h3><a class=anchor id=autotoc_md80></a>util.hpp</h3><p>Utility functions and constants exclusive to testing and benchmarking. Not split into interface/implementation.<h3><a class=anchor id=autotoc_md81></a>utests.cpp</h3><h3><a class=anchor id=autotoc_md82></a>benchmark.cpp</h3><h2><a class=anchor id=autotoc_md83></a>Example programs</h2><h3><a class=anchor id=autotoc_md84></a>list_sac.cpp</h3></div></div></div></div><div id=nav-path class=navpath><ul><li class=footer>Generated by <a href=https://www.doxygen.org/index.html><img class=footer src=doxygen.svg width=104 height=31 alt=doxygen></a> 1.9.8</ul></div>