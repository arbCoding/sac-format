* sac-format :sac_format:
** DONE Rename SacStream
It isn't a stream so it shouldn't be called one. I knew this even when I first
wrote it, but I didn't know what else to call it and figured I'd change it
later.

Maybe call it =Seismogram=, or for less typing =Trace=. Then it'd be =SAC::Trace=
which is nice.
** DONE SacStream constructor should use std::filesystem::path not std::string
** DONE Testing :testing:
*** DONE Move Unit tests from PsSp :unit:
*** DONE Benchmarks :benchmark:
*** DONE data2 read/write :unit:
*** DONE not =equal_within_tolerance= :unit:
*** DONE =legacy_write= read/write :unit:
** TODO New functionality :functionality:

*** TODO Great Circle Arc calculation

Use [[https://en.wikipedia.org/wiki/Haversine_formula][Haversine]] formula to start. Later can move on to Lambert's formula for long
lines ([[https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines][Wikipedia]])

[[file:~/my_git/sac-format/src/sac_format.hpp::void calc_gcarc();]]

***** DONE n-vector for distance calculations

[[https://en.wikipedia.org/wiki/N-vector][Wikipedia]], it has no singularities (unlike standard latitude/longitude).

[[file:~/my_git/sac-format/src/sac_format.hpp::void calc_gcarc();]]

****** Turns out it is really quite simple to use

[[https://www.ffi.no/en/research/n-vector/n-vector-explained][Norwegian Defense Research Establishment]]
[[https://github.com/FFI-no/n-vector][GitHub]]

They provide an explanation (including using the ellipticity of the Earth) and
matlab codes. I can write up a C++ version.

They also provide a reference paper: [[https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf][Gade (2010)]]

******* n-vector (normal)

$\mathbf{n}_{AB}^{C}$ is the normal vector, from $A \rightarrow B$ in reference
frame $C$ ($C$ is often $E$ for Earth, $A$ is often $E$ for center of Earth).

******** Calculate n-vector from lat/lon

$\mathbf{n}_{EA}^{E} = \left[ sin(\lambda), sin(\mu)\cdot cos(\lambda),
-cos(\mu)\cdot \cos(\lambda) \right]$

where $\lambda \in \left[-\frac{\pi}{2},\frac{\pi}{2}\right]$
is latitude and $\mu \in \left(-\pi,\pi\right]$

******* p-vector (position)

$\mathbf{p}_{EA}^{E}$ is the position vector, from the center of the Earth to
position $A$.

********* calculate p-vector from n-vector

$\mathbf{p}_{EA}^{A} = \frac{b}{\sqrt{(n_{x}^{E})^{2} +
\frac{a^{2}}{b^{2}}(n_{y}^{E})^{2} +
\frac{a^{2}}{b^{2}}(n_{z}^{E})^{2}}}\left[n_{x}^{E},\frac{a^{2}}{b^{2}}n_{y}^{E},\frac{a^{2}}{b^{2}}n_{z}^{E}\right] +
h\mathbf{n}_{EA}^{A}$

where $a,b$ are the semi-major and semi-minor axes of the reference ellipsoid
model being used.

*NOTE* that usually for a reference ellipsoid we use $a,f$, where $a$ is the semi-major axis and $f$ is the inverse flattening and then to calculate $b$ use $b=a*(1-f)$.

For *WGS84*: $a=6378137$ meters and $f=\frac{1}{298.257223563}$.

******* Distances between two points on surface of Earth

$\Delta\mathbf{p}_{AB}^{E} = \mathbf{p}_{EB}^{E} - \mathbf{p}_{EA}^{E}$ is the distance vector

Then, distance is then $\lvert \Delta\mathbf{p}_{AB}^{E} \rvert =
\sqrt{\Delta\mathbf{p}_{AB}^{E}\cdot\Delta\mathbf{p}_{AB}^{E}}$ and the
horizontal distance is the same, without the vertical component.

****** Simpler

$\Delta\sigma = arctan\left(\frac{\lvert\mathbf{n}_{1}\times\mathbf{n}_{2}\rvert}{\mathbf{n}_{1}\cdot\mathbf{n}_{2}}\right)$ (assumes spherical Earth)

***** TODO Link paired headers
e.g., az and baz should be linked, if one is edited the other is updated
Location parameters (stla, stlo, evla, evlo) should be linked to dist and gcarc.

***** TODO Azimuth
function n_EA_E_and_EB_E2azimuth from

[[https://github.com/pbrod/nvector/blob/v0.7.0/src/nvector/_core.py][GitHub]]

****** Summary

******** Step 1

Rotation matrix
$\mathbf{E} =
\begin{pmatrix}
0 & 0 & 1\\
0 & 1 & 0\\
-1 & 0 & 0
\end{pmatrix}$

defines coordinate system where the x-direction points toward (latitude,
longitude) = (0, 0) and z-direction points to the north pole.

Takes $a,f$ (semi-major and inverse flattening), plus $\mathbf{n}_{EA}^{E}$ and $\mathbf{n}_{EB}^{E}$.
******** Step 2

First calculate $\mathbf{p}_{AB}^{E}=\mathbf{p}_{EB}^{E}-\mathbf{p}_{EA}^{E}$. They use $\mathbf{E}\cdot\mathbf{n}_{EB}^{E}$ to calculate $\mathbf{p}_{EB}^{E}$, scale it using equation 22 from Gade to get $\mathbf{p}_{EL}^{E}$ (coordiante system L, with same n-vector as B), but lies at the center of the Earth).

Then finish the rotation with
$\mathbf{p}_{EB}^{E} = \mathbf{E}^{T}\cdot \mathbf{p}_{EL}^{E} - \mathbf{n}_{EB}^{E} * h)$ (depth is h in equation 22) (they use depth = 0 for each vector).

******** Step 3

Then Get $\mathbf{R}_{EN}$ (n_E2R_EN) (this function is the meat of the
calculation it seems).

******** Step 4

Then it seems you do a modified (?) version of
$\mathbf{R}_{EN}\cdot\mathbf{p}_{AB}^{E}$ to calculate $\mathbf{p}_{AB}^{N}$,
but they do weird python stuff with mdot, rollaxis (looks like they swap axis 0
and 1 [is axis a row or a column?]), and reshape. Their original version is
$\mathbf{p}_{AB}^{N}=\mathbf{R}_{EM}^{T}\cdot\mathbf{p}_{AB}^{E}$ (T means
transpose).

******** Step 5

Then the azimuth in radians is atan2$(\mathbf{p}_{AB}^{N}[1], \mathbf{p}_{AB}^{N}[0])$.

*** TODO Read-inspect function
Like read, but it prints to std::cout for every header it readers (not data
vectors!) in case you want to inspect a potentially corrupt SAC-file.
*** TODO ASCII read/write support :ascii:
**** TODO Fortran style text files.
***** TODO Read in
***** TODO Write out
*** TODO Support Big-Endian sac-files (currently only little-endian)

** DONE Refactor Trace :refactor:
*** DONE Remove boost dependency
The only reason I need boost is for boost::algorithm::trim(); to remove leading
and trailing white spaces. I feel like that is not a great reason to require
boost (which is a HUGE library)
*** DONE Getters and setters
*** DONE Store data in single-type arrays
**** DONE Use lookup table
Lookup table to keep track of where data is stored.
**** DONE Maintain only doubles of the header/footer pairs (e.g., stla/f_stla)
The only time this matters is at read/write. On read, we can read it in as a
float and immediately =static_cast<double>=. On writing, we just
=static_cast<float>= prior to writing. This will get rid of the need to deal with
simultaneously updating the double and float versions (hard to remember which is
which).
** DONE Use Enum class for lookup table, not string_view.
** TODO CI/CD GitHub workflow
*** DONE Testing
**** DONE Ubuntu :linux:
**** DONE Windows :windows:
**** DONE macOS :macos:
*** DONE Code Coverage
*** TODO Analysis :analysis:
**** DONE Code Analysis :code:
**** TODO ReviewDog :misc:
***** TODO Vale (spelling and grammar) :spelling:gammar:
**** DONE Style :style:
***** DONE CPPLint workflow
Will fail if don't comply.
*** TODO Automate release notes
*** TODO Package for download
I think ReviewDog has a yml that could work as an example for this action
** DONE Documentation :documentation:
*** DONE Update README.org :readme:
Short and succinct
*** DONE GitHub.io website :website:
**** DONE Use [[https://olmon.gitlab.io/org-themes/readtheorg_inline/readtheorg_inline.html][ReadTheOrg Inline]] ([[https://github.com/fniessen/org-html-themes][GitHub]])
*** DONE Fill in documentation :details:
**** DONE Sac format
**** DONE Quickstart
**** DONE Getters/Setters
**** DONE Trace class
**** DONE Low-level I/O
**** DONE Testing
**** DONE Benchmarking
**** DONE Example programs
**** DONE Dependencies
*** DONE PDF :pdf:
This involves setting up the export settings for the website for LaTeX.
** TODO Example programs
*** DONE list_sac
*** TODO convert_sac
1) convert between v6 and v7
2) convert between binary and ascii
*** TODO inspect_sac
** DONE Namespace sacfmt
** DONE Make single-header!
* Inbox
