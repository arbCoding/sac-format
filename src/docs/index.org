#+options: ':t *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:nil e:t
#+options: email:t expand-links:t f:t inline:t num:nil p:nil pri:nil prop:nil
#+options: stat:t tags:t tasks:t tex:t timestamp:nil title:t toc:t todo:t |:t
#+title: sac-format
#+date: <2023-11-15 Wed>
#+author: Alexander R. Blanchette
#+email: arbCoding@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 29.1 (Org mode 9.7)
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
--------------
* Introduction
sac-format is a single-header statically-linked library designed to make working
with binary [[https://ds.iris.edu/files/sac-manual/manual/file_format.html][SAC]]-files as easy as possible. I wrote sac-format in the 2020
standard of the C++ programming language (C++20), which has the benefit of being
easy to read. It follows the SAC-file format specifications---it is incomplete
where the specification is incomplete (XYZ files and a few header conventions,
see below for details).

** Why sac-format
sac-format is Free and Open Source Software (FOSS) released under the MIT
license. Anyone can use it, for any purpose (including proprietary software),
anywhere in the world. It is operating system agnostic and confirmed to run on
Windows, macOS, and Linux systems.
*** High-level Trace class
sac-format includes the =Trace= class for seismic traces that provides high-level
object-oriented abstraction to seismic data. With the =Trace= class, you don't
need to worry about manually reading SAC-files word-by-word. It is compatible
with =v6= and =v7= SAC-files and can automatically detect the version upon reading.
File output defaults to =v7= SAC-files and there is a legacy-write function for =v6=
output.
*** Low-level I/O
If you want to roll your own SAC-file processing workflow you can use the
low-level I/O functionality built into sac-format. All functions are tested and
confirmed working---they're used to build the =Trace= class!
*** Safe
sac-format is *safe*---testing is an important part of software development. The
sac-format library is extensively tested using the [[https://github.com/catchorg/Catch2][Catch2]] testing framework.
Everything from low-level binary conversions to high-level =Trace= reading/writing
are tested and confirmed working. New tests added when they are imagined.
*** Fast
sac-format is *fast*---along with extensive testing, it is also extensively
benchmarked. Run the benchmarks yourself to determine how sac-format performs on
your system.
*** Easy
sac-format is *easy*---it is single-header and object-oriented. It is easy to
integrate into any project using [[https://cmake.org/][CMake]]. See the [[Quickstart]] section to get up and
running immediately.
*** Compact
In total (header + implementation--excluding comments) sac-format is under 1000
lines of code. This small size makes it easy to use on any sort of hardware
(such as a [[https://www.raspberrypi.com/][Raspberry Pi]]).

* Quickstart
** Cmake Integration
** Build Instructions
** Examples
*** Empty Trace class
#+name: empty_trace_example
#+begin_src cpp :cache yes :returns code :results verbatim :flags -std=c++20 -L../../bin/libsac-format.a -I../
#include <iostream>
#include <sac_format.hpp>

using namespace sacfmt;

int main() {
    Trace trace{};
    std::cout << trace.kstnm << '\n';
    return EXIT_SUCCESS;
}
#+end_src

#+RESULTS[54cc08fec9656b4ff5aec836cc57b715d6b9acf4]: empty_trace_example
: -12345

* Notes
** Why C++20 and not C++23
Compiler restrictions---many of the features of C++23 [[https://en.cppreference.com/w/cpp/compiler_support/23][require]] GCC-13+ and
Clang-16+. Many systems, especially older ones, still use GCC-12 and
Clang-15---which has excellent support for [[https://en.cppreference.com/w/cpp/compiler_support/20][C++20]].

My goals are for sac-format to be accessible and modern---C++20 provides the bet
fit.
** Dependencies
** Endianness
MacOS is a little-endian system, meaning it expects binary values to start from
the Least-Significant Bit (LSB). Linux is a big-endian system and expects binary
values to start from the Most-Significan Bit (MSB). This means that MacOS
reads/writes chunks of binary data from right-to-left, while on Linux it is done
from left-to-right. For most I/O this was a non-issue. However, for strings it
resulted in some amusing results.

For example: on MacOS, KEVNM header would be read in as "Central Californ" (16
character limit for that header) and Linux would read it as "fornCaliral Cent".
The difference is easy to understand if we make the following map:

1 = "Cent", 2 = "ral", 3 = "Cali", 4 = "forn"

The Mac output is "1234", while Linux output is "4321". I have fixed this by
checking system endianness in the string reading functions. If you get any funky
results, you should confirm the endianness of the input file.

This was not an issue with any other portions of the data in the binary file,
only the strings.
